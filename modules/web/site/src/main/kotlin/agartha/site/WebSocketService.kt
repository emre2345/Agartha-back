package agartha.site

import agartha.data.objects.PractitionerDBO
import agartha.data.objects.SessionDBO
import agartha.data.services.IPractitionerService
import agartha.site.objects.webSocket.WebSocketMessage
import org.eclipse.jetty.websocket.api.Session

/**
 * Purpose of this class is to handle a hashMap that is used to
 * keep track of which practitioners that is connected to the WebSocketServer
 *
 * Created by Rebecca Fransson on 2018-06-11
 */
class WebSocketService(private val mService: IPractitionerService) {
    private val practitionersSessions = HashMap<Session, MutableList<SessionDBO>>()

    /**
     * Add The webSocketSession and practitioners latest session to the Map
     */
    fun connect(webSocketSession: Session, webSocketMessage: WebSocketMessage): SessionDBO {
        // Get the practitioner
        val practitioner: PractitionerDBO = mService.getById(webSocketMessage.data)!!
        // Get practitioners last session
        val practitionersLatestSession: SessionDBO = practitioner.sessions.last()
        // Put practitioners session and webSocket-session to a map
        practitionersSessions.put(webSocketSession, listOf(practitionersLatestSession))
        return practitionersLatestSession
    }

    /**
     * Add The webSocketSession and practitioners latest session to the Map
     */
    fun connectAnother(webSocketSession: Session, webSocketMessage: WebSocketMessage): SessionDBO {
        // Get the practitioner
        val practitioner: PractitionerDBO = mService.getById(webSocketMessage.data)!!
        // Get practitioners last session
        val practitionersLatestSession: SessionDBO = practitioner.sessions.last()
        // Find the practitionerSession from the webSocketSession
        val sessions = practitionersSessions.get(webSocketSession)
        // If there is a session for this practitioners webSocket
        if (sessions != null) {
            // Then make a mutable sessionList and add the practitionersSession to the sessionList
            val sessionList = mutableListOf<SessionDBO>()
            sessionList.add(practitionersLatestSession)
            // Update the hasMap with the webSocketSession and the new sessionList
            practitionersSessions.put(webSocketSession, sessionList)
        }
        return practitionersLatestSession
    }

    /**
     * Remove the webSocketSession from the Map
     */
    fun disconnect(webSocketSession: Session): SessionDBO? {
        // Remove the practitioners session from the list
        val removedSession = practitionersSessions.remove(webSocketSession)
        if (removedSession != null) {
            // return the first element in the list(The session that is the original)
            return removedSession[0]
        }
        return null
    }

    /**
     * Return the Map
     */
    fun getPractitionersSessionMap(): HashMap<Session, List<SessionDBO>> {
        return practitionersSessions
    }

    /**
     * Return a list with all the sessions in the map (even the ones that is generated by other practitioners)
     */
    fun getAllPractitionersSessions(): List<SessionDBO> {
        val sessions = mutableListOf<SessionDBO>()
        // Loop all the lists with sessions, add all the sessions in those lists into a mutableList
        practitionersSessions.values.forEach {
            for (session in it) {
                sessions.add(session)
            }
        }
        // Return all the lists
        return sessions
    }

    /**
     * Return the Maps size
     */
    fun getPractitionersSessionsSize(): Number {
        return practitionersSessions.values.size
    }
}